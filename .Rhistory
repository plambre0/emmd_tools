devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
dat <- simulate_emm(n = 50, p = 10, k = 2)
res <- detect_emm(dat, outcome = "Y", exposure = "A")
print(res)
plot_emm(res)
devtools::test()
devtools::load_all()
dat <- simulate_emm(n = 50, p = 10, k = 2)
res <- detect_emm(dat, outcome = "Y", exposure = "A")
print(res)
plot_emm(res)
devtools::test()
devtools::load_all()
plot_emm(res)
devtools::load_all()
devtools::load_all()
plot_emm(res)
devtools::load_all()
plot_emm(res)
devtools::load_all()
plot_emm(res)
devtools::load_all()
plot_emm(res)
devtools::load_all()
devtools::load_all()
plot_emm(res)
test_that("detect_emm recovers true modifiers in gaussian simulation", {
set.seed(123)
dat <- simulate_emm(n = 300, p = 20, k = 3, family = "gaussian")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian")
# At least one true modifier should be selected
expect_true(any(true_mods %in% res$selected))
# All selected modifiers should be among covariates
expect_true(all(res$selected %in% colnames(dat)))
})
test_that("detect_emm recovers true modifiers in gaussian simulation", {
set.seed(123)
dat <- simulate_emm(n = 300, p = 20, k = 3, family = "gaussian")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian")
# At least one true modifier should be selected
expect_true(any(true_mods %in% res$selected))
# All selected modifiers should be among covariates
expect_true(all(res$selected %in% colnames(dat)))
})
test_that("detect_emm recovers true modifiers in binomial simulation", {
set.seed(456)
dat <- simulate_emm(n = 400, p = 25, k = 2, family = "binomial")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "binomial")
expect_true(any(true_mods %in% res$selected))
})
test_that("interaction estimates are close to true values", {
set.seed(789)
dat <- simulate_emm(n = 500, p = 15, k = 2, family = "gaussian")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian")
# For each true modifier that was selected, check estimate magnitude
for (m in intersect(true_mods, res$selected)) {
est <- res$estimates[[m]][1, "Estimate"]
expect_gt(abs(est), 0.3)   # should be non-trivial
expect_lt(abs(est), 2.0)   # should not be absurdly large
}
})
test_that("p-value adjustment returns expected length", {
pvals <- c(0.01, 0.04, 0.20)
adj <- adjust_pvalues(pvals, method = "BH")
expect_equal(length(adj), length(pvals))
expect_true(all(adj >= pvals))  # BH adjusted p-values are >= raw
})
test_that("plot_emm produces a plot", {
set.seed(321)
dat <- simulate_emm(n = 200, p = 10, k = 2, family = "gaussian")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian")
if (length(res$selected) > 0) {
expect_silent(plot_emm(res))
} else {
succeed("No modifiers selected, skipping plot test")
}
})
test_that("power check: true modifiers recovered in repeated sims", {
set.seed(999)
n_sims <- 50
hits <- 0
for (i in seq_len(n_sims)) {
dat <- simulate_emm(n = 300, p = 20, k = 2, family = "gaussian")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian")
if (any(true_mods %in% res$selected)) hits <- hits + 1
}
expect_gt(hits / n_sims, 0.7)  # expect >70% recovery rate
})
context("Statistical validation: sensitivity, specificity, power, and robustness")
# Helper to run a single experiment and return metrics
run_experiment <- function(n = 300, p = 20, k = 2, family = "gaussian",
s = "lambda.1se", maxit = if (family == "binomial") 1e6 else 1e5,
thresh = 1e-07) {
dat <- simulate_emm(n = n, p = p, k = k, family = family)
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A",
family = family, s = s, maxit = maxit, thresh = thresh)
selected <- res$selected
tp <- length(intersect(selected, true_mods))
fp <- length(setdiff(selected, true_mods))
fn <- length(setdiff(true_mods, selected))
prec <- if ((tp + fp) > 0) tp / (tp + fp) else NA_real_
rec  <- if ((tp + fn) > 0) tp / (tp + fn) else 0
list(tp = tp, fp = fp, fn = fn, precision = prec, recall = rec, selected = selected, true = true_mods)
}
# Aggregate over multiple simulations
aggregate_sims <- function(n_sims = 50, ...) {
mets <- replicate(n_sims, run_experiment(...), simplify = FALSE)
tp <- sapply(mets, `[[`, "tp")
fp <- sapply(mets, `[[`, "fp")
fn <- sapply(mets, `[[`, "fn")
prec <- sapply(mets, `[[`, "precision")
rec <- sapply(mets, `[[`, "recall")
list(
tp_mean = mean(tp),
fp_mean = mean(fp),
fn_mean = mean(fn),
precision_mean = mean(prec, na.rm = TRUE),
recall_mean = mean(rec),
power = mean(rec > 0) # proportion of runs with any true modifier recovered
)
}
test_that("Power and specificity at baseline (gaussian, n=300, k=2)", {
set.seed(1001)
agg <- aggregate_sims(n_sims = 50, n = 300, p = 20, k = 2, family = "gaussian", s = "lambda.1se")
expect_gt(agg$power, 0.7)            # >70% of runs detect at least one true modifier
expect_gt(agg$recall_mean, 0.5)      # average recall > 50%
expect_gt(agg$precision_mean, 0.6)   # average precision > 60%
expect_lt(agg$fp_mean, 2)            # average false positives per run < 2
})
context("Statistical validation: sensitivity, specificity, power, and robustness")
# Helper to run a single experiment and return metrics
run_experiment <- function(n = 300, p = 20, k = 2, family = "gaussian",
s = "lambda.1se", maxit = if (family == "binomial") 1e6 else 1e5,
thresh = 1e-07) {
dat <- simulate_emm(n = n, p = p, k = k, family = family)
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A",
family = family, s = s, maxit = maxit, thresh = thresh)
selected <- res$selected
tp <- length(intersect(selected, true_mods))
fp <- length(setdiff(selected, true_mods))
fn <- length(setdiff(true_mods, selected))
prec <- if ((tp + fp) > 0) tp / (tp + fp) else NA_real_
rec  <- if ((tp + fn) > 0) tp / (tp + fn) else 0
list(tp = tp, fp = fp, fn = fn, precision = prec, recall = rec, selected = selected, true = true_mods)
}
# Aggregate over multiple simulations
aggregate_sims <- function(n_sims = 50, ...) {
mets <- replicate(n_sims, run_experiment(...), simplify = FALSE)
tp <- sapply(mets, `[[`, "tp")
fp <- sapply(mets, `[[`, "fp")
fn <- sapply(mets, `[[`, "fn")
prec <- sapply(mets, `[[`, "precision")
rec <- sapply(mets, `[[`, "recall")
list(
tp_mean = mean(tp),
fp_mean = mean(fp),
fn_mean = mean(fn),
precision_mean = mean(prec, na.rm = TRUE),
recall_mean = mean(rec),
power = mean(rec > 0) # proportion of runs with any true modifier recovered
)
}
test_that("Power and specificity at baseline (gaussian, n=300, k=2)", {
set.seed(1001)
agg <- aggregate_sims(n_sims = 50, n = 300, p = 20, k = 2, family = "gaussian", s = "lambda.1se")
expect_gt(agg$power, 0.7)            # >70% of runs detect at least one true modifier
expect_gt(agg$recall_mean, 0.5)      # average recall > 50%
expect_gt(agg$precision_mean, 0.6)   # average precision > 60%
expect_lt(agg$fp_mean, 2)            # average false positives per run < 2
})
context("Statistical validation: sensitivity, specificity, power, and robustness")
# Helper to run a single experiment and return metrics
run_experiment <- function(n = 300, p = 20, k = 2, family = "gaussian",
s = "lambda.1se", maxit = if (family == "binomial") 1e6 else 1e5,
thresh = 1e-07) {
dat <- simulate_emm(n = n, p = p, k = k, family = family)
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A",
family = family, s = s, maxit = maxit, thresh = thresh)
selected <- res$selected
tp <- length(intersect(selected, true_mods))
fp <- length(setdiff(selected, true_mods))
fn <- length(setdiff(true_mods, selected))
prec <- if ((tp + fp) > 0) tp / (tp + fp) else NA_real_
rec  <- if ((tp + fn) > 0) tp / (tp + fn) else 0
list(tp = tp, fp = fp, fn = fn, precision = prec, recall = rec, selected = selected, true = true_mods)
}
# Aggregate over multiple simulations
aggregate_sims <- function(n_sims = 50, ...) {
mets <- replicate(n_sims, run_experiment(...), simplify = FALSE)
tp <- sapply(mets, `[[`, "tp")
fp <- sapply(mets, `[[`, "fp")
fn <- sapply(mets, `[[`, "fn")
prec <- sapply(mets, `[[`, "precision")
rec <- sapply(mets, `[[`, "recall")
list(
tp_mean = mean(tp),
fp_mean = mean(fp),
fn_mean = mean(fn),
precision_mean = mean(prec, na.rm = TRUE),
recall_mean = mean(rec),
power = mean(rec > 0) # proportion of runs with any true modifier recovered
)
}
test_that("Power and specificity at baseline (gaussian, n=300, k=2)", {
set.seed(1001)
agg <- aggregate_sims(n_sims = 50, n = 300, p = 20, k = 2, family = "gaussian", s = "lambda.1se")
expect_gt(agg$power, 0.7)            # >70% of runs detect at least one true modifier
expect_gt(agg$recall_mean, 0.5)      # average recall > 50%
expect_gt(agg$precision_mean, 0.6)   # average precision > 60%
expect_lt(agg$fp_mean, 2)            # average false positives per run < 2
})
context("Comprehensive statistical validation of emmd library")
# Guard: skip dangerous/dead-end fits
skip_if_constant_Y <- function(dat, outcome = "Y") {
y <- dat[[outcome]]
if (isTRUE(sd(y) == 0)) skip("Outcome Y is constant; skipping glmnet fit.")
}
# Single experiment run with metrics
run_experiment <- function(n, p, k, family,
s = "lambda.1se",
maxit = if (family == "binomial") 1000000 else 100000,
thresh = 1e-07,
standardize.response = FALSE) {
dat <- simulate_emm(n = n, p = p, k = k, family = family)
skip_if_constant_Y(dat, "Y")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(
dat, outcome = "Y", exposure = "A", family = family,
s = s, maxit = maxit, thresh = thresh, standardize.response = standardize.response
)
selected <- res$selected
tp <- length(intersect(selected, true_mods))
fp <- length(setdiff(selected, true_mods))
fn <- length(setdiff(true_mods, selected))
prec <- if ((tp + fp) > 0) tp / (tp + fp) else NA_real_
rec  <- if ((tp + fn) > 0) tp / (tp + fn) else 0
list(
selected = selected, true = true_mods,
tp = tp, fp = fp, fn = fn,
precision = prec, recall = rec,
estimates = res$estimates,
p_adjusted = res$p_adjusted
)
}
# Aggregate metrics over simulations
aggregate_sims <- function(n_sims, n, p, k, family,
s = "lambda.1se",
maxit = if (family == "binomial") 1000000 else 100000,
thresh = 1e-07,
standardize.response = FALSE,
seed = 2024) {
set.seed(seed)
mets <- vector("list", n_sims)
for (i in seq_len(n_sims)) {
mets[[i]] <- run_experiment(n = n, p = p, k = k, family = family,
s = s, maxit = maxit, thresh = thresh,
standardize.response = standardize.response)
}
tp <- sapply(mets, `[[`, "tp")
fp <- sapply(mets, `[[`, "fp")
fn <- sapply(mets, `[[`, "fn")
prec <- sapply(mets, `[[`, "precision")
rec <- sapply(mets, `[[`, "recall")
list(
tp_mean = mean(tp),
fp_mean = mean(fp),
fn_mean = mean(fn),
precision_mean = mean(prec, na.rm = TRUE),
recall_mean = mean(rec),
power = mean(rec > 0),
runs = mets
)
}
# 1) Baseline validity: gaussian family
test_that("Baseline validity: gaussian detects planted EMM with good power and precision", {
agg <- aggregate_sims(n_sims = 50, n = 300, p = 20, k = 2, family = "gaussian")
expect_gt(agg$power, 0.7)            # proportion of runs with any true modifier
expect_gt(agg$recall_mean, 0.5)      # average fraction of true modifiers recovered
expect_gt(agg$precision_mean, 0.6)   # selected modifiers are mostly true
expect_lt(agg$fp_mean, 2)            # few false positives on average
})
# 2) Baseline validity: binomial family with stabilized settings
test_that("Baseline validity: binomial detects planted EMM under stable cv.glmnet controls", {
agg <- aggregate_sims(n_sims = 40, n = 400, p = 25, k = 2, family = "binomial",
s = "lambda.1se", maxit = 1000000, thresh = 1e-07, standardize.response = FALSE)
expect_gt(agg$power, 0.6)
expect_gt(agg$precision_mean, 0.55)
expect_lt(agg$fp_mean, 3)
})
# 3) Estimation accuracy: sign and magnitude for detected true interactions
test_that("Estimates align in sign/magnitude for detected true interactions (gaussian)", {
dat <- simulate_emm(n = 600, p = 20, k = 3, family = "gaussian")
skip_if_constant_Y(dat, "Y")
true_mods <- attr(dat, "true_modifiers")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian",
s = "lambda.1se", maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
for (m in intersect(true_mods, res$selected)) {
est <- res$estimates[[m]][1, "Estimate"]
expect_gt(est, 0.2)
expect_lt(est, 2.0)
}
})
# 4) Calibration at the null (no true modifiers)
test_that("Calibration: under null (k=0), adjusted p-values are not spuriously small", {
dat <- simulate_emm(n = 500, p = 20, k = 0, family = "gaussian")
skip_if_constant_Y(dat, "Y")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian",
s = "lambda.1se", maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
if (length(res$selected) > 0) {
adj <- res$p_adjusted[res$selected]
expect_true(median(adj, na.rm = TRUE) >= 0.1)
} else {
succeed("No selections under null; calibration acceptable.")
}
})
# 5) Robustness: power increases with sample size (gaussian)
test_that("Robustness: power increases with sample size (gaussian)", {
small <- aggregate_sims(n_sims = 30, n = 150, p = 20, k = 2, family = "gaussian")
medium <- aggregate_sims(n_sims = 30, n = 300, p = 20, k = 2, family = "gaussian")
large <- aggregate_sims(n_sims = 30, n = 600, p = 20, k = 2, family = "gaussian")
expect_lte(small$power, medium$power + 0.05)  # allow small stochastic variation
expect_lte(medium$power, large$power + 0.05)
expect_gt(large$power, 0.85)
})
# 6) Specificity: false positive rate controlled across runs (gaussian)
test_that("Specificity: false positives are limited (gaussian)", {
agg <- aggregate_sims(n_sims = 50, n = 300, p = 20, k = 2, family = "gaussian")
expect_lt(agg$fp_mean, 2)
})
# 7) Lambda choice stability
test_that("Lambda choice: lambda.1se is more conservative than lambda.min", {
min_res <- aggregate_sims(n_sims = 30, n = 300, p = 20, k = 2, family = "gaussian", s = "lambda.min")
one_se  <- aggregate_sims(n_sims = 30, n = 300, p = 20, k = 2, family = "gaussian", s = "lambda.1se")
expect_gte(min_res$fp_mean, one_se$fp_mean - 0.5)
expect_lte(one_se$recall_mean, min_res$recall_mean + 0.1)
})
# 8) End-to-end CV wrapper consistency
test_that("cv_select consistency: end-to-end flow recovers true modifiers", {
set.seed(3030)
hits <- 0
n_sims <- 30
for (i in seq_len(n_sims)) {
dat <- simulate_emm(n = 300, p = 20, k = 2, family = "gaussian")
skip_if_constant_Y(dat, "Y")
out <- cv_select(dat, outcome = "Y", exposure = "A", family = "gaussian",
s = "lambda.1se", maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
true_mods <- attr(dat, "true_modifiers")
if (any(true_mods %in% out$selected)) hits <- hits + 1
}
expect_gt(hits / n_sims, 0.6)
})
# 9) Reproducibility: fixed seed yields deterministic selections for the same data
test_that("Reproducibility: fixed seed keeps selections stable", {
set.seed(4040)
dat <- simulate_emm(n = 300, p = 20, k = 2, family = "gaussian")
skip_if_constant_Y(dat, "Y")
# Same fold structure by seed in cv_select
out1 <- cv_select(dat, outcome = "Y", exposure = "A",
family = "gaussian", s = "lambda.1se",
K = 5, seed = 123, maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
out2 <- cv_select(dat, outcome = "Y", exposure = "A",
family = "gaussian", s = "lambda.1se",
K = 5, seed = 123, maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
expect_identical(sort(out1$selected), sort(out2$selected))
})
# 10) Defensive behavior: graceful handling when no modifiers selected
test_that("Defensive: plotting and printing behave when no modifiers selected", {
dat <- simulate_emm(n = 150, p = 20, k = 0, family = "gaussian")
skip_if_constant_Y(dat, "Y")
res <- detect_emm(dat, outcome = "Y", exposure = "A", family = "gaussian",
s = "lambda.1se", maxit = 100000, thresh = 1e-07, standardize.response = FALSE)
expect_s3_class(res, "emmd_result")
# plot_emm should stop with clear message if no selected modifiers
if (length(res$selected) == 0) {
expect_error(plot_emm(res), "No selected effect modifiers")
} else {
expect_silent(plot_emm(res))
}
})
set.seed(123)
n <- 200
p <- 20
k <- 3
# covariates
X <- matrix(rnorm(n * p), nrow = n)
colnames(X) <- paste0("V", 1:p)
# exposure
A <- rbinom(n, 1, 0.5)
# true effect modifiers
true_mods <- c("V3", "V7", "V12")
beta0 <- 0.2
beta_A <- 0.5
beta_int <- rep(0, p)
names(beta_int) <- colnames(X)
beta_int[true_mods] <- c(1.2, 0.8, -1)
# linear predictor
linpred <- beta0 + beta_A * A + rowSums(sweep(X, 2, beta_int, "*") * A)
# outcome
Y <- linpred + rnorm(n, sd = 1)
# assemble data frame
df <- data.frame(Y = Y, A = A)
df <- cbind(df, as.data.frame(X))
attr(df, "true_modifiers") <- true_mods
head(df)
library(emmd)
res <- detect_emm(df, outcome = "Y", exposure = "A")
print(res)
plot_emm(res)
# Compare detected vs true
detected <- res$selected
true_mods <- attr(df, "true_modifiers")
cat("Detected modifiers:", detected, "\n")
cat("True modifiers:", true_mods, "\n")
plot(res$selector$cvfit)
res$selector$cvfit$lambda.min
res$selector$cvfit$lambda.1se
selected_1se <- coef(res$selector$cvfit, s = "lambda.1se")
selected_1se
plot(res$selector$cvfit)
res$selector$cvfit$lambda.min
res$selector$cvfit$lambda.1se
selected_1se <- coef(res$selector$cvfit, s = "lambda.1se")
selected_1se
set.seed(123)
n <- 200
p <- 20
k <- 3
# covariates
X <- matrix(rnorm(n * p), nrow = n)
colnames(X) <- paste0("V", 1:p)
# exposure
A <- rbinom(n, 1, 0.5)
# true effect modifiers
true_mods <- c("V3", "V7", "V12")
beta0 <- 0.2
beta_A <- 0.5
beta_int <- rep(0, p)
names(beta_int) <- colnames(X)
beta_int[true_mods] <- c(1.2, 0.8, -1)
# linear predictor
linpred <- beta0 + beta_A * A + rowSums(sweep(X, 2, beta_int, "*") * A)
# outcome
Y <- linpred + rnorm(n, sd = 1)
# assemble data frame
df <- data.frame(Y = Y, A = A)
df <- cbind(df, as.data.frame(X))
attr(df, "true_modifiers") <- true_mods
head(df)
library(emmd)
res <- detect_emm(df, outcome = "Y", exposure = "A")
print(res)
plot_emm(res)
# Compare detected vs true
detected <- res$selected
true_mods <- attr(df, "true_modifiers")
cat("Detected modifiers:", detected, "\n")
cat("True modifiers:", true_mods, "\n")
# Detect effect modifiers using the more conservative 1se lambda
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
# Check which modifiers were selected
detected_1se <- res_1se$selected
cat("Detected modifiers (1se):", detected_1se, "\n")
# Compare to true modifiers
true_mods <- attr(df, "true_modifiers")
cat("True modifiers:", true_mods, "\n")
# Detect effect modifiers using the more conservative 1se lambda
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
# Check which modifiers were selected
detected_1se <- res_1se$selected
cat("Detected modifiers (1se):", detected_1se, "\n")
# Compare to true modifiers
true_mods <- attr(df, "true_modifiers")
cat("True modifiers:", true_mods, "\n")
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
res_1se$selected
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
res_1se$selected
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
res_1se$selected
devtools::load_all()
devtools::load_all()
devtools::test()
devtools::test()
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
res_1se$selected
devtools::test()
devtools::test()
library(emmd)
library(emmd)
library(emmd)
devtools::test()
res_1se <- detect_emm(df, outcome = "Y", exposure = "A", lambda_type = "lambda.1se")
res_1se$selected
devtools::load_all()
devtools::test()
emmd::make_folds()
emmd::make_folds()
emmd::make_folds()
emmd::make_folds()
